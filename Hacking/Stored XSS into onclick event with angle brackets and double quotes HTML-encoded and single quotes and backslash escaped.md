
Date: 2025-09-24
Tags: 
Links: [[XSS]], [[WSA]]

***

## 1. まず前提：HTMLエスケープとは？

- サーバ側が <, >, ", ', & などの「HTMLで特別な意味を持つ文字」を &lt;, &gt;, &quot;, &apos;, &amp; に置き換える仕組み。
- これは「ユーザーが入力したものをそのままHTMLの制御文字にしないため」に使う。
- ブラウザはレスポンスを受け取ると **必ず一度デコードしてから DOM を組み立てる**。
    
## 2. どの場面で「意味を持つ」か？

### (A)

### **HTML本文のテキストノード**

```html
<div>こんにちは &lt;img&gt; </div>
```

- &lt; → < にデコードされる
- でもこの位置は「タグの外＝テキストノード」なので、ただ文字「<」として表示されるだけ。
    
    👉 **意味は持たない（安全）**
    
### (B) 
### **HTMLタグの属性値**

```
<a href="#" onclick="alert(&apos;XSS&apos;)">click</a>
```

- &apos; → ' にデコードされる
    
- ここは JavaScript が書かれているコンテキストなので、戻った ' が文字列の区切りとして解釈される。
    
    👉 **意味を持つ（危険）**
    
### (C) 
### **JavaScript文字列を HTML に埋め込んだ場合**

```
<script>
  var s = "&quot;hello&quot;";
</script>
```

- &quot; → " にデコードされる
- JSの中にそのまま入るため、文字列境界を壊す可能性がある。
    
    👉 **意味を持つ（危険）**
    
### (D) 

### **URL属性 (例: href, src)**

```
<a href="javascript:alert(&quot;XSS&quot;)">click</a>
```

- &quot; → " にデコードされる
- URL文字列の中で javascript: スキームが残ると、実行されてしまう。
    
    👉 **意味を持つ（危険）**

## 3. なぜそうなるのか？

これは **ブラウザのHTMLパーサの仕様**。

1. サーバからレスポンスを受け取る
2. パーサが文字列を走査して：
    - タグ本体 (<...>)
    - 属性 (name="value")
    - テキストノード
        などに分解する
3. そのときに **HTMLエンティティ（< や ' など）は全て「元の文字」に戻してから」DOMに渡す**

つまりブラウザは：
- **ユーザーに文字通り見せるべき部分**では「ただの文字」として出す
- **コードや属性の一部になっている部分**では「元の制御文字」に戻して解釈する
    → だから「意味を持つ」かどうかは **どのコンテキストに出力されるか**で決まるんです。
    
## 4. まとめ

- **HTML本文内** → デコードされても「ただの文字」 → 安全    
- **属性値内 / script内 / URL内** → デコードされて制御文字に戻る → 危険
    
👉 つまり質問の答えは：

「**HTMLエスケープがデコードされて意味を持つのは、タグ属性値やJavaScriptコードなど“解釈対象”の中にある場合。**」

「**それはブラウザがHTMLをDOMに変換するとき、HTMLエンティティを必ず元の文字に戻す仕様だから。**」

---
## Lab

属性値(onclick)部分に任意の文字列を挿入できる。

リクエスト
```
http://(')(")(&apos;)(&quot;)
```

レスポンスソース
```html
href="http://(\')(&quot;)(&apos;)(&quot;)"
```

DOM(ブラウザがパースしたあと)
```html
href="http://(\')(")(')(")"
```


これを利用して文字列部分を抜け出す。

***
# References

https://portswigger.net/web-security/cross-site-scripting/contexts/lab-onclick-event-angle-brackets-double-quotes-html-encoded-single-quotes-backslash-escaped